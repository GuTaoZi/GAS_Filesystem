#include "bitmap.h"

int __ffs(uint64_t word)
{
    uint64_t num = 0;

    if ((word & 0xffffffff) == 0)
    {
        num += 32;
        word >>= 32;
    }
    if ((word & 0xffff) == 0)
    {
        num += 16;
        word >>= 16;
    }
    if ((word & 0xff) == 0)
    {
        num += 8;
        word >>= 8;
    }
    if ((word & 0xf) == 0)
    {
        num += 4;
        word >>= 4;
    }
    if ((word & 0x3) == 0)
    {
        num += 2;
        word >>= 2;
    }
    if ((word & 0x1) == 0)
    {
        num += 1;
    }
    return num;
}

uint64_t find_next_bit(const uint64_t *addr, uint64_t size, uint64_t offset)
{
    const uint64_t *p = addr + BIT_WORD(offset);
    uint64_t result = offset & ~(BITS_PER_LONG - 1);
    uint64_t tmp;

    if (offset >= size)
        return size;
    size -= result;
    offset %= BITS_PER_LONG;
    if (offset)
    {
        tmp = *(p++);
        tmp &= (~0UL << offset);
        if (size < BITS_PER_LONG)
            goto found_first;
        if (tmp)
            goto found_middle;
        size -= BITS_PER_LONG;
        result += BITS_PER_LONG;
    }
    while (size & ~(BITS_PER_LONG - 1))
    {
        if ((tmp = *(p++)))
            goto found_middle;
        result += BITS_PER_LONG;
        size -= BITS_PER_LONG;
    }
    if (!size)
        return result;
    tmp = *p;

found_first:
    tmp &= (~0UL >> (BITS_PER_LONG - size));
    if (tmp == 0UL)           /* Are any bits set? */
        return result + size; /* Nope. */
found_middle:
    return result + __ffs(tmp);
}

uint64_t find_next_zero_bit(const uint64_t *addr, uint64_t size, uint64_t offset)
{
    const uint64_t *p = addr + BIT_WORD(offset);
    uint64_t result = offset & ~(BITS_PER_LONG - 1);
    uint64_t tmp;

    if (offset >= size)
        return size;
    size -= result;
    offset %= BITS_PER_LONG;
    if (offset)
    {
        tmp = *(p++);
        tmp |= ~0UL >> (BITS_PER_LONG - offset);
        if (size < BITS_PER_LONG)
            goto found_first;
        if (~tmp)
            goto found_middle;
        size -= BITS_PER_LONG;
        result += BITS_PER_LONG;
    }
    while (size & ~(BITS_PER_LONG - 1))
    {
        if (~(tmp = *(p++)))
            goto found_middle;
        result += BITS_PER_LONG;
        size -= BITS_PER_LONG;
    }
    if (!size)
        return result;
    tmp = *p;

found_first:
    tmp |= ~0UL << size;
    if (tmp == ~0UL)          /* Are any bits zero? */
        return result + size; /* Nope. */
found_middle:
    return result + ffz(tmp);
}

void bitmap_set(uint64_t *map, int start, int nr)
{
    uint64_t *p = map + BIT_WORD(start);
    const int size = start + nr;
    int bits_to_set = BITS_PER_LONG - (start % BITS_PER_LONG);
    uint64_t mask_to_set = BITMAP_FIRST_WORD_MASK(start);

    while (nr - bits_to_set >= 0)
    {
        *p |= mask_to_set;
        nr -= bits_to_set;
        bits_to_set = BITS_PER_LONG;
        mask_to_set = ~0UL;
        p++;
    }
    if (nr)
    {
        mask_to_set &= BITMAP_LAST_WORD_MASK(size);
        *p |= mask_to_set;
    }
}

void bitmap_clear(uint64_t *map, int start, int nr)
{
    uint64_t *p = map + BIT_WORD(start);
    const int size = start + nr;
    int bits_to_clear = BITS_PER_LONG - (start % BITS_PER_LONG);
    uint64_t mask_to_clear = BITMAP_FIRST_WORD_MASK(start);

    while (nr - bits_to_clear >= 0)
    {
        *p &= ~mask_to_clear;
        nr -= bits_to_clear;
        bits_to_clear = BITS_PER_LONG;
        mask_to_clear = ~0UL;
        p++;
    }
    if (nr)
    {
        mask_to_clear &= BITMAP_LAST_WORD_MASK(size);
        *p &= ~mask_to_clear;
    }
}

uint64_t bitmap_find_next_zero_area(uint64_t *map, int size, int start, int nr, uint64_t align_mask)
{
    uint64_t index, end, i;
again:
    index = find_next_zero_bit(map, size, start);

    /* Align allocation */
    index = __ALIGN_MASK(index, align_mask);

    end = index + nr;
    if (end > size)
        return end;
    i = find_next_bit(map, end, index);
    if (i < end)
    {
        start = i + 1;
        goto again;
    }
    return index;
}

uint64_t bitmap_alloc_region(uint64_t *bitmap, int size, int start, int nr)
{
    uint64_t pos = bitmap_find_next_zero_area(bitmap, size, start, nr, 0);
    if (pos > size) // not found
        return 0;

    bitmap_set(bitmap, pos, nr);
    return pos;
}

void bitmap_free_region(uint64_t *bitmap, int pos, int nr)
{
    bitmap_clear(bitmap, pos, nr);
}
